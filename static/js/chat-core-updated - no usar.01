// chat-core.js
// Este script contiene la l√≥gica compartida del chatbot, usada por el widget flotante y el embed en el panel admin.

// üõ†Ô∏è 1. Mostrar el mensaje inicial de bienvenida
function initializeChat() {
  const welcomeMessage = "Hello! How can I assist you today? If you have any questions about storage, reservations, or anything else related to The Lock Up Self Storage, feel free to ask.";
  addMessage(welcomeMessage, 'bot');
}

// üí¨ 2. Enviar mensaje del usuario al hacer clic en el bot√≥n
function sendMessage() {
  const inputField = document.getElementById('user-input');
  const userMessage = inputField.value.trim();

  if (!userMessage) return;

  addMessage(userMessage, 'user');
  inputField.value = '';
  saveToHistory(userMessage, 'user');

  fetchBotResponse(userMessage);
}

// üîÅ 3. Cargar historial de chat desde sessionStorage
function loadChatHistory() {
  const chatHistory = JSON.parse(sessionStorage.getItem('chatHistory')) || [];
  chatHistory.forEach(msg => {
    addMessage(msg.text, msg.sender);
  });
}

// üíæ 4. Guardar mensaje en sessionStorage para persistencia temporal
function saveToHistory(text, sender) {
  const history = JSON.parse(sessionStorage.getItem('chatHistory')) || [];
  history.push({ text, sender });
  sessionStorage.setItem('chatHistory', JSON.stringify(history));
}

// üì• 5. Recibir respuesta del backend
// Modificar la funci√≥n fetchBotResponse para usar el nuevo procesador JSON
async function fetchBotResponse(message) {
  try {
    // Mostrar indicador de carga
    const loadingId = showLoadingIndicator();
    
    const response = await fetch('/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message })
    });

    // Procesar la respuesta como JSON
    const data = await response.json();
    console.log("üõ†Ô∏è Respuesta estructurada del backend:", data);
    
    // Ocultar indicador de carga
    hideLoadingIndicator(loadingId);
    
    // Usar el nuevo procesador JSON
    processResponseJson(data);

  } catch (error) {
    console.error('‚ùå Error al obtener respuesta del backend:', error);
    const fallbackMessage = "Oops! There was an issue reaching the server. Please try again later.";
    addMessage(fallbackMessage, 'bot');
    saveToHistory(fallbackMessage, 'bot');
    hideLoadingIndicator();
  }
}

// üîÑ Mostrar indicador de carga mientras se espera la respuesta
function showLoadingIndicator() {
  const chatMessages = document.getElementById('chat-messages');
  const loadingElem = document.createElement('div');
  const loadingId = 'loading-' + Date.now();
  loadingElem.id = loadingId;
  loadingElem.classList.add('message', 'bot-message');
  loadingElem.innerHTML = `
    <div class="bot-message-content">
      <img src="../static/assets/the-lock-up.svg" class="bot-icon" alt="Bot">
      <div class="bot-formatted-message">
        <div class="typing-indicator">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </div>
    </div>
  `;
  chatMessages.appendChild(loadingElem);
  chatMessages.scrollTop = chatMessages.scrollHeight;
  return loadingId;
}

// ‚èπÔ∏è Ocultar indicador de carga
function hideLoadingIndicator(loadingId) {
  if (loadingId) {
    const loadingElem = document.getElementById(loadingId);
    if (loadingElem) loadingElem.remove();
  }
}

// üß© 6. Procesar diferentes tipos de respuestas del backend
function processResponse(data) {
  if (!data || !data.type || !data.content) {
    addMessage("I received an empty or malformed response. Please try again.", 'bot');
    return;
  }

  const type = data.type;
  const content = data.content;

  // üîÑ Enrutamiento por tipo de respuesta
  if (type === "text" && content.message) {
    addMessage(content.message, 'bot');
    saveToHistory(content.message, 'bot');
  }

  else if (type === "locations" && Array.isArray(content.locations)) {
    if (content.message) {
      addMessage(content.message, 'bot');
      saveToHistory(content.message, 'bot');
    }
    renderLocations(content.locations);
  }

  else if (type === "nearby_locations" && Array.isArray(content.locations)) {
    renderNearbyLocations(content.locations, content.userLocation || "your area");
  }

  else if (type === "specific_location" && content.location) {
    renderSpecificLocation(content.location);
  }

  else if (type === "contact_request" && content.message) {
    addMessage(content.message, 'bot');
    saveToHistory(content.message, 'bot');
  }

  else if (type === "error" && content.message) {
    addMessage(content.message, 'bot');
    saveToHistory(content.message, 'bot');
  }

  else if (type === "no_locations" && content.message) {
    addMessage(content.message, 'bot');
    saveToHistory(content.message, 'bot');
  }

  else {
    // üßØ Fallback por tipo desconocido
    console.warn("‚ö†Ô∏è Tipo de respuesta no reconocido:", data);
    addMessage("I received a response, but I don't know how to display it. Please try asking something else.", 'bot');
  }
}

// üìç 7. Renderizar lista de ubicaciones
function renderLocations(locations) {
  let html = `<div class="bot-message-content">
    <img src="../static/assets/the-lock-up.svg" class="bot-icon" alt="Bot">
    <div class="bot-formatted-message">
      <p>Here are the locations I found:</p>
      <ul class="locations-list">`;

  locations.forEach(location => {
    html += `
      <li class="location-item">
        <strong>${location.name}</strong><br>
        ${location.address}<br>
        <a href="tel:${location.phone}" class="location-phone">${location.formattedPhone || location.phone}</a>
      </li>`;
  });

  html += `</ul></div></div>`;

  addMessage(html, 'bot');
  saveToHistory(html, 'bot');
}

// üó∫Ô∏è 8. Renderizar ubicaciones cercanas
function renderNearbyLocations(locations, searchLocation) {
  let html = `<div class="bot-message-content">
    <img src="../static/assets/the-lock-up.svg" class="bot-icon" alt="Bot">
    <div class="bot-formatted-message">
      <p>Here are the locations nearest to "${searchLocation}":</p>
      <ul class="locations-list">`;

  locations.forEach(location => {
    const distance = location.distance?.miles
      ? ` (${location.distance.miles} miles)`
      : '';
    html += `
      <li class="location-item">
        <strong>${location.name}</strong>${distance}<br>
        ${location.address}<br>
        <a href="tel:${location.phone}" class="location-phone">${location.formattedPhone || location.phone}</a>
      </li>`;
  });

  html += `</ul></div></div>`;

  addMessage(html, 'bot');
  saveToHistory(html, 'bot');
}

// üè¢ 9. Renderizar detalles de una ubicaci√≥n espec√≠fica
function renderSpecificLocation(location) {
  const address = location.address || "Address not available";
  const phone = location.formattedPhone || location.phone || "Phone not available";
  const hours = location.hours || "Contact store for hours";
  const units = location.units || "Call for availability";

  const html = `<div class="bot-message-content">
    <img src="../static/assets/the-lock-up.svg" class="bot-icon" alt="Bot">
    <div class="bot-formatted-message">
      <div class="location-detail">
        <h4>${location.name}</h4>
        <p>${address}</p>
        <p><strong>Phone:</strong> <a href="tel:${location.phone}">${phone}</a></p>
        <p><strong>Hours:</strong> ${hours}</p>
        <p><strong>Available Units:</strong> ${units}</p>
      </div>
    </div>
  </div>`;

  addMessage(html, 'bot');
  saveToHistory(html, 'bot');
}

// üß± 10. Agregar un mensaje al DOM con soporte para HTML
function addMessage(text, sender) {
  const chatMessages = document.getElementById('chat-messages');
  if (!chatMessages) {
    console.warn("‚ö†Ô∏è No se encontr√≥ el contenedor de mensajes. ¬øSe llam√≥ a addMessage antes de crear el DOM?");
    return;
  }

  const messageElem = document.createElement('div');
  messageElem.classList.add('message');
  
  if (sender === 'user') {
    messageElem.classList.add('user-message');
    messageElem.textContent = text; // Para mensajes de usuario usamos texto plano
  } else {
    messageElem.classList.add('bot-message');
    // Para mensajes del bot podemos incluir HTML
    if (text.startsWith('<div class="bot-message-content">')) {
      messageElem.innerHTML = text; // Ya tiene el formato correcto
    } else {
      // Formatear texto simple como un mensaje estructurado
      const formatted = formatBotText(text);
      messageElem.innerHTML = `
        <div class="bot-message-content">
          <img src="../static/assets/the-lock-up.svg" class="bot-icon" alt="Bot">
          <div class="bot-formatted-message">${formatted}</div>
        </div>
      `;      
    }
  }

  chatMessages.appendChild(messageElem);
  chatMessages.scrollTop = chatMessages.scrollHeight; // Desplazamiento autom√°tico
}

// üßæ 10 bis. Formatear texto del bot con soporte de Markdown, HTML y listas anidadas
// Funci√≥n mejorada para formatear texto del bot
function formatBotText(text) {
  // Si la respuesta ya est√° en HTML, devolverla tal cual
  if (text.includes('<div') || text.includes('<p') || text.includes('<ul') || text.includes('<ol')) {
    return text;
  }

  // 1. Preservar los bloques de c√≥digo
  let codeBlocks = [];
  text = text.replace(/```([^`]+)```/g, (match) => {
    codeBlocks.push(match);
    return '%%CODE_BLOCK_' + (codeBlocks.length - 1) + '%%';
  });

  // 2. Procesar formato b√°sico
  let html = text
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // **negrita**
    .replace(/\*(.*?)\*/g, '<em>$1</em>')             // *cursiva*
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>'); // enlaces markdown

  // 3. Procesar pasos numerados y listas anidadas
  // Identificar secuencias como "1. paso uno", "2. paso dos" o "Paso 1:", "Paso 2:"
  html = html.replace(/(?:^|\n)(?:\d+\.|(?:Paso|Step)\s+\d+:)\s*(.*?)(?=(?:\n(?:\d+\.|(?:Paso|Step)\s+\d+:))|$)/gs, 
    function(match, content) {
      // Si contiene vi√±etas (detectamos por - o ‚Ä¢)
      if (content.includes("\n-") || content.includes("\n‚Ä¢")) {
        // Dividir el contenido por l√≠neas
        const lines = content.trim().split("\n");
        let result = lines[0]; // La primera l√≠nea es el t√≠tulo del paso
        
        // Procesar el resto como una lista de bullets
        result += "<ul>";
        for (let i = 1; i < lines.length; i++) {
          if (lines[i].trim().startsWith("-") || lines[i].trim().startsWith("‚Ä¢")) {
            result += "<li>" + lines[i].trim().substring(1).trim() + "</li>";
          } else if (lines[i].trim()) {
            // Si no es un bullet pero tiene contenido, agregar como p√°rrafo o como parte del bullet anterior
            result += "<p>" + lines[i].trim() + "</p>";
          }
        }
        result += "</ul>";
        return result;
      }
      return match; // Si no contiene vi√±etas, dejar como est√°
    }
  );
  
  // 4. Convertir secuencias de numeraci√≥n manual a lista ordenada
  html = html.replace(/(?:^|\n)(?:(\d+)\.\s*(.*?)(?=\n\d+\.\s*|\n\n|$))+/gs, function(match) {
    const lines = match.trim().split(/\n/);
    let result = "<ol>";
    
    lines.forEach(line => {
      const itemMatch = line.match(/^\d+\.\s*(.*)/);
      if (itemMatch) {
        result += "<li>" + itemMatch[1] + "</li>";
      }
    });
    
    result += "</ol>";
    return result;
  });

  // 5. Convertir secuencias "Paso X:" a lista ordenada con class especial
  html = html.replace(/(?:^|\n)(?:(?:Paso|Step)\s+\d+:)\s*(.*?)(?=\n(?:(?:Paso|Step)\s+\d+:)|\n\n|$)/gs, function(match) {
    const lines = match.trim().split(/\n/);
    let result = "<ol class='steps'>";
    
    lines.forEach(line => {
      const itemMatch = line.match(/^(?:Paso|Step)\s+\d+:\s*(.*)/);
      if (itemMatch) {
        result += "<li>" + itemMatch[1] + "</li>";
      }
    });
    
    result += "</ol>";
    return result;
  });

  // 6. Convertir bloques de bullets a listas no ordenadas
  html = html.replace(/(?:^|\n)(?:\s*[-‚Ä¢]\s+(?:.*?)(?:\n|$))+/g, function(match) {
    const lines = match.trim().split(/\n/);
    let result = "<ul>";
    
    lines.forEach(line => {
      const itemMatch = line.match(/^\s*[-‚Ä¢]\s+(.*)/);
      if (itemMatch) {
        result += "<li>" + itemMatch[1] + "</li>";
      }
    });
    
    result += "</ul>";
    return result;
  });

  // 7. Restaurar los bloques de c√≥digo
  html = html.replace(/%%CODE_BLOCK_(\d+)%%/g, function(match, blockIndex) {
    const code = codeBlocks[parseInt(blockIndex)]
      .replace(/```(?:\w+)?\n?/, '')  // Quitar la apertura del bloque
      .replace(/```$/, '');           // Quitar el cierre
    return '<pre><code>' + code + '</code></pre>';
  });

  // 8. Convertir los saltos de l√≠nea en <br> para el texto restante
  html = html.replace(/\n/g, '<br>');

  return html;
}

// 10.bis plus
// Funci√≥n para manejar casos espec√≠ficos de formateo de JSON
function processResponseJson(data) {
  // Si la respuesta ya tiene el formato esperado (type y content)
  if (data.type && data.content) {
    return processResponse(data);
  }
  
  // Si recibimos un formato diferente, convertirlo al formato esperado
  let formattedResponse = {
    type: "text",
    content: {
      message: ""
    }
  };
  
  // Caso 1: Si es un objeto con una propiedad 'answer' (formato FAQ)
  if (data.answer) {
    formattedResponse.content.message = data.answer;
    processResponse(formattedResponse);
    return;
  }
  
  // Caso 2: Si es un array de respuestas
  if (Array.isArray(data)) {
    // Tomamos la primera respuesta relevante
    const firstResponse = data.find(item => item.answer || item.message || item.text);
    if (firstResponse) {
      formattedResponse.content.message = firstResponse.answer || firstResponse.message || firstResponse.text;
      processResponse(formattedResponse);
      return;
    }
  }
  
  // Caso 3: Si es un objeto simple con propiedades como 'message' o 'text'
  if (data.message || data.text) {
    formattedResponse.content.message = data.message || data.text;
    processResponse(formattedResponse);
    return;
  }
  
  // Si no se pudo interpretar, mostrar un mensaje gen√©rico
  console.warn("‚ÑπÔ∏è No se pudo interpretar la respuesta:", data);
  formattedResponse.content.message = "Recib√≠ una respuesta que no puedo mostrar correctamente. Intenta preguntar de otra manera.";
  processResponse(formattedResponse);
}


// ‚å®Ô∏è 11. Enviar mensaje con Enter
function setupEnterKeySubmission() {
  const input = document.getElementById('user-input');
  if (!input) return;

  input.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      sendMessage();
    }
  });
}
